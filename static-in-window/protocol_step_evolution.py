#Add directory with Frederik's code to path
from sys import path
path.insert(0,"../Frederik/")

from gaussian_bath import bath,get_J_ohmic
from basic import get_tmat

#import jump_static as js
import jump_static_optimized as js
from integrate import time_evolve
from params import *

from numpy.linalg import eigh,norm
from scipy.linalg import expm
from numpy import linspace,diag,cos,exp


from time import perf_counter

if __name__ == "__main__":

## Shamelessly stolen from Frederik
	# Derive physical quantities from parameters
	impedance   = planck_constant/(2*quantization_parameter*e_charge**2)
	L           = impedance/cavity_frequency
	C           = 1/(cavity_frequency*impedance)
	inductance  = 1*L
	resistance  = hbar*omega0/(2*pi*e_charge**2*gamma)

	# Grid of discretized phi values 
	phi_cutoff  = N_wells*2*pi
	phi         = linspace(-phi_cutoff,phi_cutoff,D)
	dphi        = phi[1]-phi[0]

	well_projector = 1-(-1)**(phi/(2*pi)//1)-1 #What's with the extra -1??


	## OPERATORS ##
	# Dimensionless phase \phi 
	Phi     = diag(phi)
	X1 = expm(1j*Phi)
	X2 = expm(-1j*Phi)

	# Canonically conjugate momentum to Phi (q)
	Tmat    = get_tmat(D,dtype=complex)
	Pi0     = 1j*(Tmat-eye(D))/dphi

	# Squared momentum (note the symmetrization of the operator)
	Pi_2 = 0.5*(Pi0@Pi0.conj().T + Pi0.conj().T@Pi0)

	# Squared charge operator 
	Q2 = ((2*e_charge)/hbar)**2 * Pi_2 

	# Circuit Hamiltonian (w/o Josephson junction)
	H0pot = Phi**2/(2*L)*(hbar**2/(4*e_charge))
	H0kin = Q2/(2*C)

	H0 = H0pot + H0kin

	#Diagonalize H0 (needed for computing jump operators)
	_E0,_V0 = eigh(H0)

	#Truncate the Hilbert space to keep only the N_trunc lowest lying
	#	energy levels
	E0 , V0 = _E0[:N_trunc] , _V0[:,:N_trunc] 

	# Josephson potential 
	V  = Josephson_energy * diag(cos(phi))
	H1 = H0 + V

	#H1 and H0 in the truncated Hilbert space
	H0_trunc = diag(E0)
	H1_trunc = V0.conj().T @ H1 @ V0


	## BATH ##

	# Spectral function
	J = get_J_ohmic(Temp,omega_c,omega0=omega0)

	# Frequency resolution  (only used to  calculating bath timescales in ULE module).
	wvec = linspace(-10*2*pi/dt_JJ,10*2*pi/dt_JJ,10000)
	dw = wvec[1]-wvec[0]

	# Bath object
	B = bath(J,10*omega_c,10*omega_c/4000)

#Now onto original(-ish) stuff by me

	#Fourier components for the resistor coupling W(t)
	#W_fourier = [1j*(1-exp(1j*Omega*q*dt_JJ))/(2*pi*q) for q in range(-q_max,q_max+1)]
	W_fourier = [sqrt(pi*tau)*exp(-Omega*q*(4j*t_0+q*Omega*tau**2)) for q in range(-q_max,q_max+1)]
	frequencies = [Omega*q for q in range(-q_max,q_max+1)]




	## TIME EVOLUTION OPERATORS ##

	#Full Hamiltonian over one period:
	#      H = H0 0 <= t < \Delta t
	#      H = H1 \Delta t < t < T

	#Evolution while the JJ is off (ie, \Delta t < t < T (mod T)) 
	def time_evo_bare(t1,t2,energy_basis=True):
		if energy_basis:	#return in basis of H0 eigenstates
			return diag(exp(-1j*(t2-t1)*E0/hbar))
		else:	#return in phi basis
			return expm(-1j*(t2-t1)*H0/hbar)

	#Evolution while the JJ is on (ie, 0 < t < \Delta t (mod T))
	def time_evo_JJ(t1,t2,energy_basis=True):
		_U = expm(-1j*(t2-t1)*H1/hbar)
		if energy_basis:	#return in basis of H0 eigenstates
			return V0.conj().T @ _U @ V0
		else:	#return in phi basis
			return _U

	#Makes use of the two above functions to compute a general time evolution for the step protocol
	#NB: Assumes -T/2 < t1 < t2 < T/2. Time evolution with t2 < t1 can be found by hermitian conjugation
	def time_evo(t1,t2,delta_t):
		if t2 < t1:
			print("Error: expecting t2 > t1")
			exit(1)
		
		if t1 < 0:
			#If t1 < 0, there are three cases:
			#	1) t2 <= 0 as well, in which case all the evolution is generated by H0
			#	2) 0 < t2 <= delta_t, in which we evolve by H0 from t1 to 0, and by h1 from 
			#		0 to t2
			#	3) t2 > delta_t, in which case we evolve by H0 from t1 to 0, then H1 from o to 
			#		delta_t, then H0 again from delta_t to t2
			if t2 <= 0:
				return time_evo_bare(t1,t2)
			else:
				if t2 <= delta_t:
					return time_evo_JJ(0,t2) @ time_evo_bare(t1,0)
				else:
					return time_evo_bare(delta_t,t2) @ time_evo_JJ(0,delta_t) @ time_evo_bare(t1,0)

		elif t1 < delta_t:
			#If 0 < t1 < delta_t, there are two cases:
			#	1) t2 <= delta_t as well, in which we simply evolve by H1 from t1 to t2
			#	2) t2 > delta_t, in which case we evolve by H1 from t1 to delta_t, then H0 from 
			#		delta_t to t2
			if t2 <= delta_t:
				return time_evo_JJ(t1,t2)
			else:
				return time_evo_bare(delta_t,t2) @ time_evo_JJ(t1,delta_t)

		else:
			#If t1 > delta_t, then the evolution is generated only by H0
			return time_evo_bare(t1,t2)


	#Projects an arbitrary time t into the one period interval [-T/2 , T/2]
	def mod(t):
		_temp = t % T
		if _temp > T/2:
			return _temp - T
		else: 
			return _temp 


	## EFFECTIVE HAMILTONIAN FOR SSE EVOLUTION ##

	#The f function appearing in the jump operators
	#f_func = js.f(B.J,(W_fourier,frequencies),dt_JJ,gamma)

	#The system Hamiltonian (as a function of time)
	def H_t(t,trunc=True):
		if trunc:
			if (t % T) <= dt_JJ:
				return H1_trunc
		else: 
				return H0_trunc
		else:
			if (t % T) <= dt_JJ:
				return H1
			else: 
				return H0

	#Transform the physical operators to the energy basis (eigenstates of H0)
	X1_E = V0.conj().T @ X1 @ V0
	X2_E = V0.conj().T @ X2 @ V0

	#The jump operators at time t
	def jump_ops(t):
		t_proj = mod(t)	#Project t into the interval [-T/2,T/2]

		#Compute the time evolution U(delta_t,t), and its conjugate, appearing in the jump
		#	operators. Note we have to handle separately the case t < delta_t because of how 
		#	time_evo() above is defined 
		if t_proj > dt_JJ:
			U = time_evo(dt_JJ,t_proj,dt_JJ)
			U_dag = U.conj().T
		else:
			U_dag = time_evo(t_proj,dt_JJ,dt_JJ)
			U = U_dag.conj().T

		#print("doing the thing")
		#L_1 = U @ js.L_tilde_energy_basis(X1,f_func,t_proj,E0) @ U_dag
		#print("doing the second thing")
		#L_2 = U @ js.L_tilde_energy_basis(X2,f_func,t_proj,E0) @ U_dag

		L_1 = U @ js.L_tilde_energy_basis(X1_E,t_proj,E0,(W_fourier,frequencies),dt_JJ,gamma,Temp,omega_c,omega0) @ U_dag
		L_2 = U @ js.L_tilde_energy_basis(X2_E,t_proj,E0,(W_fourier,frequencies),dt_JJ,gamma,Temp,omega_c,omega0) @ U_dag

		return L_1,L_2

	# _t1 = perf_counter() 
	# jump_ops(T/2)
	# _t2 = perf_counter()
	# print("Time elapsed: {} seconds".format(_t2-_t1))

	# _t1 = perf_counter() 
	# jump_ops(T/2)
	# _t2 = perf_counter()
	# print("Time elapsed: {} seconds".format(_t2-_t1))

	# _t1 = perf_counter() 
	# L_1,L_2 = jump_ops(T/2)
	# _t2 = perf_counter()
	# print("Time elapsed: {} seconds".format(_t2-_t1))

	# print(L_1.shape)


	#Compute the effective Hamiltonian governing SSE Evolution
	def H_eff(t):
		L_1 , L_2 = jump_ops(t)
		return H_t(t) - (1j*hbar/2)*gamma*(L_1.conj().T @ L_1 + L_2.conj().T @ L_2)




	# ## SSE EVOLUTION ##

	#Initial wavefunction 
	psi_0 = zeros(N_trunc)
	psi_0[0] = 1/sqrt(2)
	psi_0[1] = 1/sqrt(2) 

	#Timestep & t values
	dt = .01*dt_JJ
	t_vals = arange(0,T+dt/2,dt)

	
	jumps = []
	well_imbalance = []
	other_paulis = []	#figure out from Frederik what this is
	#rhos = []
	#psis = []
	#wigners = []
	for sample_num in range(nsamples):
		#Keep track of jumps & imbalance for this sample
		jumps_this_sample = []
		imbalance_this_sample = []
		other_paulis_this_sample = []

		r = random()	#Random number to compare norm of wavefunction to

		psi = psi_0		#The current wavefunction, initialized to psi_0
		for i in range(num_periods):
			if i%10:
				print("Currently on cycle {} out of {}".format(i,num_periods))
			for t in t_vals:
				#Time evolve, employing the Taylor expansion method in integrate.py
				psi = time_evolve(psi,H_eff,i*T+t,dt)

				#Check if there is a quantum jump, and proceed accordingly
				if (1 - norm(psi)**2) > - r:
					jump_time = i*T+t-dt/2	#Estimate time of jump as t-dt/2

					#Get jump operators at this time
					L_1 , L_2 = jump_ops(jump_time)	

					#Determine the type of jump, and jump the wavefunction accordingly
					p_1 = norm(L_1 @ psi)**2
					p_2 = norm(L_2 @ psi)**2
					if random() < p_1/(p_1+p_2):
						jumps_this_sample.append((1,jump_time))
						psi = L_1 @ psi
					else:
						jumps_this_sample.append((2,jump_time))
						psi = L_2 @ psi

					#In either case, re-normalize the wavefunction and re-set the random variable r
					psi = psi/norm(psi)
					r = random()

				#end jump if block
			#end for loop over current cycle
			print(psi[-5:]/norm(psi))

	# 		#Measure once only every oscillation period of the bare LC circuit 
	# 		if (i % 4) == 0:
	# 			imbalance_this_sample.append(sum(abs(psi)**2*well_projector)/norm(psi)**2)
	# 			other_paulis_this_sample.append(sum(psi@psi[::-1].conj())/norm(psi)**2)

		#end for loop over cycles

	# 	jumps.append(jumps_this_sample)
	# 	well_imbalance.append(imbalance_this_sample)
	# 	other_paulis.append(other_paulis_this_sample)
	#end for loop over samples

	# #Plot the well imbalance
	# plt.figure()
	# for sample_num in range(nsamples):
	# 	plt.plot(list(range(0,num_periods,4)),imbalance_this_sample[sample_num])
	
	# plt.xlabel("Driving Period")
	# plt.ylabel("Well Imbalance")
	# plt.show()










