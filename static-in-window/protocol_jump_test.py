#Add directory with Frederik's code to path
from sys import path
path.insert(0,"../Frederik/")

from gaussian_bath import bath,get_J_ohmic
from basic import get_tmat

import jump_static_optimized as js
from integrate import time_evolution, find_timestep
from params import *

from numpy.linalg import eigh,eigvals,norm,svd
from scipy.linalg import expm
from scipy.special import gamma as gamma_fn
from numpy import linspace,diag,cos,exp,around,log2,complex128

import matplotlib.pyplot as plt

plt.rc('text',usetex=True)
plt.rc('text.latex', preamble=r'\usepackage{amsmath}')


if __name__ == "__main__":
	from sys import argv

	if len(argv) != 2:
		print("Usage: <num_points>")
		exit(0)

	num_points = int(argv[1])

## Shamelessly stolen from Frederik
	# Derive physical quantities from parameters
	impedance   = planck_constant/(2*quantization_parameter*e_charge**2)
	L           = impedance/cavity_frequency
	C           = 1/(cavity_frequency*impedance)
	inductance  = 1*L
	resistance  = hbar*omega0/(2*pi*e_charge**2*gamma)

	# Grid of discretized phi values 
	phi_cutoff  = N_wells*2*pi
	phi         = linspace(-phi_cutoff,phi_cutoff,D)
	dphi        = phi[1]-phi[0]

	## OPERATORS ##
	# Dimensionless phase \phi 
	Phi     = diag(phi)
	X1 = expm(1j*Phi)
	X2 = expm(-1j*Phi)

	# Canonically conjugate momentum to Phi (q)
	Tmat    = get_tmat(D,dtype=complex)
	Pi0     = 1j*(Tmat-eye(D))/dphi

	# Squared momentum (note the symmetrization of the operator)
	Pi_2 = 0.5*(Pi0@Pi0.conj().T + Pi0.conj().T@Pi0)

	# Squared charge operator 
	Q2 = ((2*e_charge)/hbar)**2 * Pi_2 

	# Circuit Hamiltonian (w/o Josephson junction)
	H0pot = Phi**2/(2*L)*(hbar**2/(4*e_charge))
	H0kin = Q2/(2*C)

	H0 = H0pot + H0kin

	# Josephson potential 
	V  = Josephson_energy * diag(cos(phi))
	H1 = H0 + V

	#The Hamiltonian during the window the resistor is on, and outside of it
	#Can swap these to create different protocols
	H_window_full = H1
	H_outside_full = H0

	#Diagonalize H_window (needed for computing jump operators)
	E_window_full, V_window_full = eigh(H_window_full)

	#Diagonalize H_outside
	E_outside_full , V_outside_full = eigh(H_outside_full)

	#Truncate the Hilbert space to keep only the N_trunc lowest lying
	#	energy levels
	E_window , V_window = E_window_full[:N_trunc] , V_window_full[:,:N_trunc] 
	E_outside , V_outside = E_outside_full[:N_trunc] , V_outside_full[:,:N_trunc] 

	#H_window and H_outside in the truncated Hilbert space
	H_window = diag(E_window)
	H_outside = V_window.conj().T @ H_outside_full @ V_window

#Now onto original(-ish) stuff by me

	#Fourier components for the resistor coupling W(t)
	#W_fourier = [1j*(1-exp(1j*Omega*q*dt_JJ))/(2*pi*q) for q in range(-q_max,q_max+1)]
	W_fourier = [sqrt(pi)*tau*exp(-Omega*q*(-4j*t_0+q*Omega*tau**2)/4) for q in range(-q_max,q_max+1)]
	frequencies = [Omega*q for q in range(-q_max,q_max+1)]




	## TIME EVOLUTION OPERATORS ##

	#Full Hamiltonian over one period:
	#      H = H_window 0 <= t < \Delta t
	#      H = H_outside \Delta t < t < T

	#Evolution during the window resistor is on (ie, 0 <= t1,t2 < \Delta t (mod T)) 
	def time_evo_window(t1,t2,energy_basis=True):
		if energy_basis:	#return in basis of H0 eigenstates
			return diag(exp(-1j*(t2-t1)*E_window/hbar))
		else:	#return in phi basis
			return expm(-1j*(t2-t1)*H_window_full/hbar)

	#Evolution while resistor is off (ie, \Delta t < t1,t2 < T (mod T))
	def time_evo_outside(t1,t2,energy_basis=True):
		#_U = expm(-1j*(t2-t1)*H1/hbar)
		if energy_basis:	#return in basis of H0 eigenstates
			return expm(-1j*(t2-t1)*H_outside/hbar)
		else:	#return in phi basis
			return expm(-1j*(t2-t1)*H_outside_full/hbar)

	#Makes use of the two above functions to compute a general time evolution for the step protocol
	#NB: Assumes -T/2 < t1 < t2 < T/2. Time evolution with t2 < t1 can be found by hermitian conjugation
	def time_evo(t1,t2,delta_t):
		if t2 < t1:
			print("Error: expecting t2 > t1")
			exit(1)
		
		if t1 < 0:
			#If t1 < 0, there are three cases:
			#	1) t2 <= 0 as well, in which case all the evolution is generated by H_outside
			#	2) 0 < t2 <= delta_t, in which case we evolve by H_outside from t1 to 0, and by 
			#		H_window from 0 to t2
			#	3) t2 > delta_t, in which case we evolve by H_outside from t1 to 0, then H_window 
			#		from 0 to delta_t, then H_outside again from delta_t to t2
			if t2 <= 0:
				return time_evo_outside(t1,t2)
			else:
				if t2 <= delta_t:
					return time_evo_window(0,t2) @ time_evo_outside(t1,0)
				else:
					return time_evo_outside(delta_t,t2) @ time_evo_window(0,delta_t) @ time_evo_outside(t1,0)

		elif t1 < delta_t:
			#If 0 <= t1 < delta_t, there are two cases:
			#	1) t2 <= delta_t as well, in which we simply evolve by H_window from t1 to t2
			#	2) t2 > delta_t, in which case we evolve by H_window from t1 to delta_t, then 
			#		H_outside from delta_t to t2
			if t2 <= delta_t:
				return time_evo_window(t1,t2)
			else:
				return time_evo_outside(delta_t,t2) @ time_evo_window(t1,delta_t)

		else:
			#If t1 > delta_t, then the evolution is generated only by H_outside
			return time_evo_outside(t1,t2)


	#Projects an arbitrary time t into the one period interval [-T/2 , T/2]
	def mod(t):
		_temp = t % T
		if _temp > T/2:
			return _temp - T
		else: 
			return _temp 


	## EFFECTIVE HAMILTONIAN FOR SSE EVOLUTION ##

	#The system Hamiltonian (as a function of time)
	def H_t(t,trunc=True):
		if trunc:
			if (t % T) <= dt_JJ:
				return H_window
			else: 
				return H_outside
		else:
			if (t % T) <= dt_JJ:
				return H_window_full
			else: 
				return H_outside_full

	#Transform the physical operators to the energy basis (eigenstates of H_window)
	X1_window = V_window.conj().T @ X1 @ V_window
	X2_window = V_window.conj().T @ X2 @ V_window

	X1_outside = V_window.conj().T @ X1 @ V_window
	X2_outside = V_outside.conj().T @ X2 @ V_outside

	#The jump operators at time t
	def jump_ops(t):
		t_proj = mod(t)	#Project t into the interval [-T/2,T/2]

		#Compute the time evolution U(delta_t,t), and its conjugate, appearing in the jump
		#	operators. Note we have to handle separately the case t < delta_t because of how 
		#	time_evo() above is defined 
		if t_proj > dt_JJ:
			U = time_evo(dt_JJ,t_proj,dt_JJ)
			U_dag = U.conj().T
		else:
			U_dag = time_evo(t_proj,dt_JJ,dt_JJ)
			U = U_dag.conj().T

		L_1 = U @ js.L_tilde_energy_basis(X1_window,t_proj,E_window,(W_fourier,frequencies),dt_JJ,gamma,Temp,omega_c,omega0) @ U_dag
		L_2 = U @ js.L_tilde_energy_basis(X2_window,t_proj,E_window,(W_fourier,frequencies),dt_JJ,gamma,Temp,omega_c,omega0) @ U_dag

		return L_1,L_2

	def jump_ops_static(t):
		if (t % T) <= dt_JJ:
			L_1 = js.L_static(X1_window,E_window,gamma,Temp,omega_c,omega0)
			L_2 = js.L_static(X2_window,E_window,gamma,Temp,omega_c,omega0)
		else:
			L_1 = js.L_static(X1_outside,E_outside,gamma,Temp,omega_c,omega0)
			L_2 = js.L_static(X2_outside,E_outside,gamma,Temp,omega_c,omega0)
		return L_1,L_2


	

	L1_qs0 , L2_qs0 = jump_ops_static(0)

	t_vals_window = linspace(0,dt_JJ,num=num_points)
	diffs_1 = []
	diffs_2 = []
	norms_1 = []
	norms_2 = []
	for i,t in enumerate(t_vals_window):
		if i % 5 ==0:
			print("Currently on {} of  {} in window".format(i,num_points))
		L1 , L2 = jump_ops(t)
		L1_qs = exp(-((t-t_0)/tau)**2)*L1_qs0
		L2_qs = exp(-((t-t_0)/tau)**2)*L2_qs0

		diffs_1.append(norm(L1-L1_qs,ord=2))
		diffs_2.append(norm(L2-L2_qs,ord=2))
		norms_1.append(norm(L1,ord=2))
		norms_2.append(norm(L2,ord=2))

	t_vals_outside = linspace(dt_JJ,T,num=num_points)[1:]
	for i,t in enumerate(t_vals_outside):
		if i % 5 ==0:
			print("Currently on {} of  {} outside window".format(i,num_points))
		L1 , L2 = jump_ops(t)

		diffs_1.append(norm(L1,ord=2))
		diffs_2.append(norm(L2,ord=2))
		norms_1.append(diffs_1[-1])
		norms_2.append(diffs_2[-1])

	ts = concatenate((t_vals_window,t_vals_outside))

	plt.figure(figsize=(10,8))

	plt.subplot(121)
	plt.plot(ts/T,diffs_1,label=r"$||L_1 - L_1^{\text{qs}}||$")
	plt.plot(ts/T,norms_1,label=r"$||L_1||$")

	plt.xlabel(r"$t/T$",size=20)
	plt.ylabel(r"Spectral norm",size=20)
	plt.tick_params(which="both",labelsize=15)
	plt.legend(fontsize=15)

	plt.subplot(122)
	plt.plot(ts/T,diffs_2,label=r"$||L_2 - L_2^{\text{qs}}||$")
	plt.plot(ts/T,norms_2,label=r"$||L_2||$")

	plt.xlabel(r"$t/T$",size=20)
	plt.ylabel(r"Spectral norm",size=20)
	plt.tick_params(which="both",labelsize=15)
	plt.legend(fontsize=15)

	plt.savefig("../../Figures/qs-comp-dt_JJ={}-omega={}-gamma={}.png".format(dt_JJ/Tc,cavity_frequency/GHz,gamma/meV))
